[{"content":"关于GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\n更多概念可参考相关文档：about github pages\n一些重点：\n用户站点：\u0026lt;username\u0026gt;.github.io 项目站点：http(s)://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt; 只能为 GitHub 上的每个帐户创建一个用户或组织站点。 项目站点（无论是组织还是个人帐户拥有）没有限制。 如果要创建用户或组织站点，则存储库必须命名为 \u0026lt;user\u0026gt;.github.io 或 \u0026lt;organization\u0026gt;.github.io，且名称必须使用小写字母 部署博客项目 博客项目部署在用户站点的根目录下，仓库命名根据上面的规则使用\u0026lt;user\u0026gt;.github.io格式： GitHub Pages设置 部署小项目 项目站点的仓库名会作为访问路径的一部分，同样需要在Pages中设置： 添加项目分支 添加项目的网址路径 完成后就可以通过此网址访问项目了： 访问项目 ","date":"2024-10-28T13:17:28+08:00","image":"https://morimit.github.io/2024/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAgithub-pages%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/pages0_hu15910036697814244378.png","permalink":"https://morimit.github.io/2024/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAgithub-pages%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","title":"使用一个GitHub pages部署多个项目"},{"content":"reference explainthis:DevOps 万字长文详解DevOps及DevOps工具链 阮一峰的博客 诞生背景 CI/CD是Continuous Integration（持续集成）和Continuous Delivery/Deployment（持续交付）的缩写。它产生于倡导敏捷开发的大背景下（普遍使用光盘的年代），软件开发不再是一次完成、测试后才上线交付，而是及早交付、开发者收到反馈后根据变动的需求持续改进的过程。\nCI/CD是DevOps的重要组成部分：\nDevOps工具链的核心组成部分包括：\n代码编辑和版本控制工具：如 Visual Studio Code，Sublime Text 等，它们允许开发人员编写代码并跟踪更改。 自动化构建工具：如 Jenkins，Travis CI 等，它们帮助开发人员自动化构建，测试和部署代码。 持续集成和持续部署工具：如 GitHub Actions，Jenkins X，GitLab CI/CD 等，它们帮助开发人员自动触发构建，测试和部署流程。 容器编排工具：如 Kubernetes，Docker Swarm 等，它们允许开发人员部署和管理容器化应用程序。 持续监控工具：如 Prometheus，Grafana，InfluxDB 等，它们帮助开发人员监控应用程序的运行状态和性能。 服务配置管理工具：如 Ansible，Chef，Puppet 等，它们帮助开发人员自动化配置和管理应用程序和服务。 DevOps工具链中的每个工具都旨在帮助开发人员更快地交付高质量的软件。通过这些工具，开发人员可以自动化许多重复性和耗时的任务，从而节省时间并提高生产效率。同时，DevOps工具链也可以帮助开发人员更好地理解应用程序的运行情况，并及时发现和解决问题。\n定义 CI CI指多个开发者能够共同在同个代码库中开发不同的新功能，然后在通过自动化测试后持续地整合到主干上面。\n一般来说，CI 流程会在代码推到远端分支后开始 代码格式化检查：统一代码的格式规范，确保具有符合团队设定的格式风格，例如 JavaScript 的 Prettier。 静态检查：确保有符合团队所设立的相关规则，或者有符合程式语言的规则，例如TypeScript 的 TSLint 会帮忙检查代码是否符合 TypeScript 的规则。 自动化测试：包含单元测试、功能测试、E2E 测试。 单元测试：针对函数或模块的测试 功能/集成测试：针对整体产品的某个功能的测试 端对端测试：从用户界面直达数据库的全链路测试 完成测试后构建：构建（build）指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 Jenkins Travis Codeship Strider 在业界，许多软件开发团队还会在 CI 当中加入其他更精细的检测，例如针对安全 (security) 做检测，避免写出有潜在漏洞的代码；或者对性能 (performance) 做检测，来确保代码的性能达到一定的门槛。\nCD CD指持续交付给评审团队、持续自动化部署。\n自动化测试：构建完成，就要进行第二轮全面测试。当然也可以只在构建完成后进行全面测试。 所有测试以自动化为主，少数无法自动化的测试用例就要人工跑 新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 部署：通过了前面的测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。 CD最理想的状况是当开发者把代码合并后，就会开始整合、测试，最终部署，整个流程不需用有人工介入，一切自动化完成，新的功能就会到最端使用者手上。\n","date":"2024-10-28T09:20:09+08:00","image":"https://mlops-guide.github.io/MLOps/CICDML/ci-cd.png","permalink":"https://morimit.github.io/2024/%E4%BB%80%E4%B9%88%E6%98%AFci/cd/","title":"什么是CI/CD"},{"content":"","date":"2024-10-04T17:05:36+08:00","permalink":"https://morimit.github.io/javascript/chapter1/1.1/","title":"1.1 第一节"},{"content":"第二节 ","date":"2024-10-04T17:05:36+08:00","permalink":"https://morimit.github.io/javascript/chapter1/1.2/","title":"1.2 第二节"},{"content":"第一部分 hello~ this is a test page hello~ this is a test pagehello~ this is a test page hello~ this is a test pagehello~ this is a test page hello~ this is a test pagehello~ 首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署。\n第二部分 首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署。\n首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署\n第三部分 首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署。 首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署\n首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署首先Hugo能够生成可以发布的网站文件，其次使用git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub action、GitHub pages service），所以才能顺利完成一系列自动部署\n","date":"2024-09-29T20:46:15+08:00","permalink":"https://morimit.github.io/javascript/chapter2/2.1/","title":"2.1 第一节"},{"content":"需求 将微信接龙打卡更新到考勤表中，已到的人✔，未到的人❌\n思路拆分 对比两列，一列是人员姓名（固定列），一列是此人当日打卡情况。每次微信打卡后，复制接龙到表格的对比列中，如果固定列的名字有出现在对比列中，则更新当日打卡记录。\n1cells = sheet[\u0026#39;A3:A11\u0026#39;] #固定列 2cells2 = sheet[\u0026#39;N3:N12\u0026#39;] #对比列 3cells3 = sheet[\u0026#39;C3:C11\u0026#39;] #保存到新列，每日更新 姓名\\日期 10月5日 10月6日 张三 ✔ ✔ 李四 ❌ ✔ 王五 ✔ ✔ 使用的python包：openpyxsl模块 参考教程：https://blog.csdn.net/weixin_44288604/article/details/120731317\n1import os 2import openpyxl 3import chardet 4import codecs 5 6 7path = r\u0026#34;C:\\\\Users\\\\DELL\\\\Desktop\\\\work\u0026#34; 8os.chdir(path) # 修改工作路径 9 10workbook = openpyxl.load_workbook(\u0026#39;志愿者考勤表.xlsx\u0026#39;)\t# 返回一个workbook数据类型的值 11# print(workbook.sheetnames)\t# 打印Excel表中的所有表 12 13# 选择工作表 14sheet = workbook[\u0026#39;Sheet1\u0026#39;] # 获取指定sheet表 15 16cells = sheet[\u0026#39;A3:A11\u0026#39;] #固定列 17cells2 = sheet[\u0026#39;N3:N12\u0026#39;] #对比列 18cells3 = sheet[\u0026#39;C3:C11\u0026#39;] #保存到新列，每日更新 19 20for i in cells: 21 for j in i: 22 # 打印A3到A11的数据 23 # print(j.value) 24 for k in cells2: 25 for l in k: 26 # 打印N3到N12的数据 27 # print(l.value) 28 if(l.value != None): 29 if(j.value.find(l.value) == -1): 30 print(l.row) 31 else: 32 sheet[\u0026#34;C{}\u0026#34;.format(j.row)].value = \u0026#39;✔\u0026#39; 33for k in cells3: 34 for l in k: 35 if( sheet[\u0026#34;C{}\u0026#34;.format(l.row)].value != \u0026#39;✔\u0026#39;): 36 print(l.row) 37 sheet[\u0026#34;C{}\u0026#34;.format(l.row)].value = \u0026#39;×\u0026#39; 38 39 40workbook.save(\u0026#39;志愿者考勤表.xlsx\u0026#39;) #记得保存，否则更改不生效 需求变更 要求整张表的行列对调 日期\\姓名 张三 李四 王五 10月5日 ✔ ❌ ✔ 10月6日 ✔ ✔ ✔ 1import os 2import openpyxl 3import chardet 4import codecs 5 6 7path = r\u0026#34;C:\\\\Users\\\\DELL\\\\Desktop\\\\work\\\\考勤表\u0026#34; 8os.chdir(path) # 修改工作路径 9 10workbook = openpyxl.load_workbook(\u0026#39;志愿者考勤表.xlsx\u0026#39;)\t# 返回一个workbook数据类型的值 11# print(workbook.sheetnames)\t# 打印Excel表中的所有表 12 13# 选择工作表 14sheet = workbook[\u0026#39;Sheet1\u0026#39;] # 获取指定sheet表 15alignment = openpyxl.styles.Alignment(horizontal=\u0026#34;center\u0026#34;, vertical=\u0026#34;center\u0026#34;, text_rotation=0, wrap_text=True) # 设置对齐格式 16def columnletter(col): 17 letter = [0, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;] 18 return letter[col] 19 20for i in sheet.iter_rows(min_row=2, max_row=2, min_col=2, max_col=10): 21 for j in i: 22 # 打印固定行（姓名行） 23 # print(j.value) 24 for k in sheet.iter_rows(min_row=16, max_row=16, min_col=1, max_col=10): 25 for l in k: 26 # 打印对比行（excel手动转置） 27 # print(l.value) 28 if(l.value != None): 29 if(j.value.find(l.value) == -1): 30 #print(l.column) #注意打印出来的是数字，而不是字母 31 else: 32 # ----------------------- 33 #新信息注入新行，打勾 34 # ----------------------------- 35 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(j.column))].value = \u0026#39;✔\u0026#39; 36 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(j.column))].alignment = alignment 37# ----------------------------- 38#新信息注入新行，打叉 39# ----------------------------- 40for k in sheet.iter_rows(min_row=5, max_row=5, min_col=2, max_col=10): 41 for l in k: 42 if( sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].value != \u0026#39;✔\u0026#39;): 43 print(l.column) 44 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].value = \u0026#39;×\u0026#39; 45 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].alignment = alignment 46 47workbook.save(\u0026#39;志愿者考勤表.xlsx\u0026#39;) ","date":"2023-10-05T09:58:39+08:00","image":"https://morimit.github.io/2023/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel/openpyxl_hu3109027507448300676.PNG","permalink":"https://morimit.github.io/2023/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel/","title":"使用Python操作Excel"},{"content":"本章图片来源：hugo in action\n博客类型 从博客使用者的角度，按照是否有后台能够在线编辑博文，博客可分为：\n静态博客 动态博客 从博客开发的角度看，动态博客多了应用服务器和数据库的部分。 典型动态博客架构 | 来源：https://www.manning.com/books/hugo-in-action 一些流行的Web技术栈包括LAMP(Linux、Apache、MySQL、PHP)、Microsoft.NET(IIS、ASP.NET、MS SQL Server)、MEAN(MongoDB、Express、Angular、Node.js)和MERN(MongoDB、Express、Reaction、Node.js)。\n像Apache或IIS这样的Web服务器主要在传统的Web技术栈中托管静态资产，如图像、JavaScript和CSS,这些静态文件不会在多个用户之间更改。 第二组资产是动态内容，可以有所不同，它基于提供的请求参数，包括URL，请求标头，cookie或相关的HTTP POST数据，安装了PHP、ASP.NET或Express等软件的应用程序服务器会获取这些参数并创建响应\n动态博客 可以登录并进入网页后台在线编写文章、管理评论，发布和修改文章比静态博客方便，可以实时更新 搭建时需要租用/购买服务器，要考虑服务器的安全问题 halo 开源建站工具，不用写代码，直接生成网页，但要有一台可访问公网的服务器（云主机或实体服务器），并需要进行以下服务器配置：\n服务器的连接与管理：SSH工具（如SecureCRT）、SFTP工具（向服务器上传文件） 服务器应用安装与环境部署 准备网站源码或安装包（jar包）进行部署。 防火墙开放8090端口，这是网站打开访问的端口 (xxx.xxx.xxx.xxx:8090）。 可以下载一些主题包，在控制台页面安装。 在服务器上安装nginx。一般来说我们不会用jar包启动的8090端口的服务去直面用户，而是会在中间加一层代理服务器做转发服务（负载均衡、扛并发）。常用的代理服务器就是nginx（默认在80端口启动web服务）。 配置nginx，让它代理到jar包启动的地址（xxx.xxx.xxx.xxx:8090），即可不用写8090端口访问。 Wordpress 可用docker搭建；基于PHP语言；搭建步骤大致如下：\n购买主机和域名 安装docker 搭建博客。下载docker-compose.yml文件，再用一行命令启动博客（yml文件里包含了从docker官方仓库拉取服务镜像，包括mysql和需要的web服务）。 登录（localhost:8000），选择语言、登录账户设置，即可以看到博客后台。 最后可更换主题和插件 静态博客 使用博客生成器生成网站（一个包含一堆HTML文件的文件夹），每次发布/修改内容都需要重新生成此文件夹 网站放在托管平台，利用GitHub Pages、Netlify、vercel等可以做免费托管，无需购买服务器 利用GitHub Actions实现简单的CI/CD 缺点是扩展时受限于生成器提供的API 了解博客生成器之前，最好先了解Jamstack。J、A、M分别代表JavaScript、APIs、Markup，也即此技术栈的核心：\nJamstack | 来源：https://www.manning.com/books/hugo-in-action 首次发出获取HTML页面的请求运行时Jamstack与传统Web技术栈的对比： 与动态站点的web技术栈对比 | 来源：https://www.manning.com/books/hugo-in-action 使用Jamstack，编译步骤已经执行了数据库处理和基于应用程序逻辑的拼接。 这种HTML生成并不是针对每个请求都发生的。 因此，该请求不需要通过互联网访问原始服务器。 而是在地理位置上靠近客户端的CDN提供内容。\n可以看到Jamstack将大部分逻辑从应用程序中移出到web服务器，与应用程序服务器相比，web服务器的安全问题和维护需求更少，如果使用托管服务，则能最大程度减少维护工作。\nHugo 基于Go语言；生成站点的速度非常快。\nHexo 基于Node.js，很多主题稍作修改后Hugo也可以用。\n","date":"2023-03-16T09:33:30+08:00","image":"https://morimit.github.io/2023/different-blog-types/hugo_hu13633332523079484905.PNG","permalink":"https://morimit.github.io/2023/different-blog-types/","title":"Different Blog Types"},{"content":"添加文章 关于notes和posts 本博客中二者的划分可查看：notes和posts区域\n添加posts文章 不需要指定模板，Hugo会使用 archetypes/default.md模板来建立文档：\n1hugo new post/my-first-post.md 添加notes文章 指定模板，使用命令hugo new [文件路径]/[文件名].md -k [archetype name]\n比如添加JavaScript这个笔记，需要按照如下格式：\n在./content目录下新建javascript文件夹和_index.md 1hugo new javascript/_index.md -k note-section.md 在./content/javascript目录下添加chapter： 1hugo new javascript/chapter1/_index.md -k note-section.md 在./content/javascript/chapter1目录下添加每一节： 1hugo new javascript/chapter1/1.1/index.md -k note.md 最后可以用hugo server 命令查看修改效果，如果再加上--buildDrafts可以查看草稿文件 ： sample note 将本地变化推送到远程仓库 1git pull 2git add . #添加修改后的所有文件到stage area 3git commit -m \u0026#34;添加评论\u0026#34; #把stage area的文件提交到分支 4git push origin main #推送到源码仓库 5# 最后可在`https://xxxxx.github.io` 处查看发布好的网站。 改动博客样式 切换到测试分支开发 1git branch #查看所有分支 2git checkout -b test #新建并切换到test分支 完成后合并到main分支 1git switch main #切换到main分支 2git merge --no-ff -m \u0026#34;merge with no-ff\u0026#34; test #在非fast forward模式下合并分支 3git log --graph --pretty=online --abbrev-commit #可以查看合并结果 4git push origin main 5#手动删除远程仓库内的test分支 6git branch -d test #删除本地test分支 7git fetch --prune #删除远程仓库中删除的分支的引用 ","date":"2023-01-11T20:59:31+08:00","image":"https://morimit.github.io/2023/blog-workflow/Journey2_hu8411419062215487271.png","permalink":"https://morimit.github.io/2023/blog-workflow/","title":"Blog Workflow"},{"content":"场景 需要用一台（Windows）电脑同时连接多个GitHub账号。\n建立SSH连接 创建两个SSH key 在终端输入以下命令：\n1ssh-keygen -t rsa -f ~/.ssh/id_rsa_m -C \u0026#34;firstmail@gmail.com\u0026#34; #绑定一个GitHub账号所用的邮箱 2ssh-keygen -t rsa -f ~/.ssh/id_rsa -C \u0026#34;secondmail@gmail.com\u0026#34; #绑定另一个GitHub账号的邮箱 添加SSH公钥到对应GitHub账号中 两个SSH key分别配置在对应GitHub账号中： sshkey 本地添加新SSH密钥到SSH agent中 在终端中输入命令：\n1ssh-add -D #清空本地的SSH缓存 2ssh-add ~/.ssh/id_rsa 3ssh-add ~/.ssh/id_rsa_m 4ssh-add -l 若提示 Could not open a connection to your authentication agent. 则先执行命令 ssh-agent bash 即可。\n修改本地配置文件 要在本地配置文件中设置不同账号和SSH key的对应关系，就需要在 ~/.ssh/config 文件（没有就新建一个）中设置不同仓库指向不同的密钥文件：\n1#第一个账号 2Host github.com # 这里域名随意写，标识账号1 3HostName github.com #这里域名就是我们要访问的远程服务器域名github.com 4User git #可以随意填写 5IdentityFile ~/.ssh/id_rsa #私钥位置 6 7# 第二个账号 8Host second.github.com #标识账号2 9HostName github.com 10User git 11PreferredAuthentications publickey 12IdentityFile ~/.ssh/id_rsa_m 测试SSH连接 在终端中执行命令\n1ssh -T git@github.com 2ssh -T git@second.github.com 提示 Hi Morimit! You've successfully authenticated, but GitHub does not provide shell access 则为成功。\n配置git 配置项目文件夹信息 在项目文件夹中打开终端并执行以下命令：\n1# 取消全局 用户名/邮箱 配置 2$ git config --global --unset user.name 3$ git config --global --unset user.email 4# 进入项目文件夹，单独设置每个repo 用户名/邮箱 5$ git config user.email \u0026#34;xxxx@xx.com\u0026#34; 6$ git config user.name \u0026#34;xxxx\u0026#34; 7$ git config --list 配置远程仓库信息 注意设置远程仓库的时候，需要与 config 文件中的Host名称对应。\n1$ git remote rm origin 2# 远程仓库地址，注意Host名称 3$ git remote add origin git@second.github.com:githubUserName/repName.git 4$ git remote -v # 查看远程 将本地仓库上传到远程仓库 push测试：\n1git add . 2git commit -m \u0026#34;自行添加注释\u0026#34; 3git push origin main #推送到远端main分支 流程总结 确保SSH连接成功 在项目文件夹目录下打开git bash终端。 将文件夹设为git仓库： git init 在本地添加远程仓库的SSH地址 1git remote add origin git@second.github.com:Morimit/Morimit_source.git (注意这里的账号名 git@second.github.com 是和 ~/.ssh/config 文件中配置一致的) 配置git账号: git config user.name \u0026quot;Morimit\u0026quot; 和 git config user.email \u0026quot;firstmail@gmail.com\u0026quot; 。 添加到暂存区和提交到当前分支： git add . 、 git commit -m \u0026quot;comments\u0026quot; 推送到远程仓库： git push origin main 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream \u0026lt;branch-name\u0026gt; origin/\u0026lt;branch-name\u0026gt;。 参考 github-手把手教程-本地如何连接多个github仓库_Vivi_static的博客-CSDN博客 Git之同一台电脑连接多个远程仓库 - zhengyan_web - 博客园 (cnblogs.com) 本地Git仓库关联多个远程仓库的两种方法 - 知乎 (zhihu.com) ","date":"2023-01-10T16:22:12+08:00","image":"https://morimit.github.io/2023/connect-git-to-github/SSH_hu14026105570980821268.PNG","permalink":"https://morimit.github.io/2023/connect-git-to-github/","title":"Connect Git to Github"},{"content":"Reference GitHub Actions 入门教程 Build Hugo With GitHub Action Create and host a blog with Hugo and GitHub Pages in less than 30 minutes Creating a personal access token 基于 Github Action 自动构建 Hugo 博客 - (lixueduan.com)：讲清楚了GitHub Action中的.yml配置文件代码具体是怎样连接GitHub上的两个仓库的 折腾Hugo | GitHub Pages | Github Actions自动构建发布免费个人网站 - 知乎 (zhihu.com) ：看完就能知道怎么给GitHub上的两个仓库配置公钥私钥 使用 Hugo + GitHub Actions 升级博客 // 风行\u0026rsquo;s Blog (lijingcheng.github.io) ssh-keygen 生成密钥 Prerequisite 建立好本地仓库和GitHub的连接：Connect Git to GitHub\nSteps Github Actions是GitHub提供的，使用脚本的大致作用如下：\nThe GitHub Action is going to grab the content from the XXX_source repository, build it using Hugo and push the output into the XXX repository.\n创建一个新的SSH密钥对： 1ssh-keygen -t rsa -b 4096 -C \u0026#34;yourmail@mail.com\u0026#34; -f ~/.ssh/gh-pages -N \u0026#34;\u0026#34; 给绑定GitHub Pages的公开仓库添加公钥： ssh-pub 给源码仓库添加私钥： 注意：此 private key 的名称之后要填入 Action 脚本的特定位置。 ssh-private 给源码仓库添加脚本 在源码仓库中找到Actions栏，新建workflow： new workflows 可以直接找到workflow的模板： workflow templates template 可以在右侧查看actions市场和GitHub Actions的使用文档： actions \u0026amp; docs 修改脚本内容 一些专用术语：\nworkflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 脚本内容修改如下：\n1name: Deploy Hugo Site to Github Pages on Main Branch 2 3# 触发条件是git push 4on: 5 push: 6 branches: 7 - main 8 - test 9 10jobs: 11 build-deploy: 12 runs-on: ubuntu-latest 13 steps: 14 - uses: actions/checkout@v1 # v2 does not have submodules option now 15 # with: 16 # submodules: true 17 18 - name: Setup Hugo 19 uses: peaceiris/actions-hugo@v2 20 with: 21 hugo-version: \u0026#39;latest\u0026#39; 22 extended: true 23 24 - name: Build 25 run: hugo --minify 26 27 - name: Deploy 28 uses: peaceiris/actions-gh-pages@v3 29 with: 30 deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名 31 external_repository: Morimit/Morimit.github.io # Pages绑定的远程仓库 32 publish_dir: \u0026#34;./public\u0026#34; 33 keep_files: false # remove existing files 34 publish_branch: main # deploying branch 35 commit_message: ${{ github.event.head_commit.message }} 注意：publish_branch要和该仓库绑定GitHub Pages的发布branch相一致 上面的步骤完成后，每次从本地git push源文件到GitHub都会触发GitHub Actions脚本把./public文件夹更新到GitHub pages。 搭建完成后的workflow workflow\n","date":"2023-01-10T13:50:03+08:00","image":"https://morimit.github.io/2023/building-blog-with-github-actions/actions_hu5151252319927733192.PNG","permalink":"https://morimit.github.io/2023/building-blog-with-github-actions/","title":"Building Blog With GitHub Actions"},{"content":"博客规划 定位 明确自己的核心需求就两个：\n技术笔记本 一些其他posts 页面规划 主页 参考一些博客、小说、视频、新闻网站，展示页适合使用摊开的卡片形式，可以一目了然地看到所有posts的信息 posts在本博客中是使用tags来管理的、互相没有上下级关联的博文 笔记 存放所有notes——以文档的形式罗列，每个note都具有总体章节目录和本节内容目录 notes在本博客中是使用notes分类来管理、互相之间有层级关系的博文，且不会出现在主页展示 由于页面的布局很满了，所以目录的滚动条都要隐藏，鼠标放在目录上能滚动即可 还有有种方式是折叠目录，但我更喜欢摊开的感觉 项目 存放一些小项目。\n存档 存放所有notes和posts中的博文，考虑到博文的数量，按年份来分隔比较合理，并且不需要分页，因为分页有种切割了时间流的感觉。\n关于 关于网站的信息和一些碎碎念。\nRSS订阅 可以使用inoreader等RSS阅读器来订阅博文。\n搭建记录 一句话总结 首先Hugo能够生成可以发布的静态网站文件，其次使用Git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub Actions、GitHub Pages），所以才能顺利完成一系列自动部署。\n初始化git仓库 git是一个分布式版本控制系统，可以用来追踪博客的成长变动。\n把存放博客的文件夹变成一个git仓库：\n1git init 本地安装Hugo 安装环境：Windows 10 安装步骤参考官方文档，或者中文文档 在这里我安装预编译的二进制版本，此版本是已经编译好的应用程序，不依赖Go环境，优点是可以直接运行，缺点是不能直接修改源码。\n下载后需要添加环境变量，这样才能够在不同的文件夹中使用Hugo程序。在系统变量和用户变量的Path中都添加： hugo文件夹添加到系统变量 然后就可以进入想要存放博客的文件夹，使用命令创建新站：\n1 hugo new site 项目名 此时在根目录文件夹下可以发现Hugo已经创建了一些文件夹： 文件夹框架 选择并了解Hugo主题 本博客主题选用参考了Hugo-stack-theme 主题魔改版 stack主题的特点之一是使用原生JS和CSS代码，没有使用框架。 直接下载Stack主题到./themes文件夹中，并按照主题readme文档的提示进行一些配置。\n再回到根目录下使用命令来预览：\n1hugo server 这条命令会在运行内存中构建网站，并让网页跑在一个最小化的HTTP server中，这意味着可以一边修改网站一边看到修改效果。\nExample Site 关于web server更详细的解释：\nWhile the server is running, it watches your project directory for changes to assets, configuration, content, data, layouts, translations, and static files. When it detects a change, the server rebuilds your site and refreshes your browser using LiveReload.\nabout LiveReload: While the server is running, Hugo injects JavaScript into the generated HTML pages. The LiveReload script creates a connection from the browser to the server via web sockets. You do not need to install any software or browser plugins, nor is any configuration required.\n注意Hugo都是从根目录开始渲染的，所以如果根目录的layouts和contents有内容，就会忽略themes文件夹中的同名文件夹。\n以及如果出现不同后缀名的config文件，不同格式的优先级是toml\u0026gt;yaml\u0026gt;json。\n（优先级细节可查看官方文档的lookup order）\n创建网站 真正创建网站的是下面一行命令：\n1hugo 此命令会在网站根目录下创建public文件夹，这里存放的就是整个完整的网站，如果把public文件夹放在IIS之类的web服务器上，稍加修改config.yaml文件中的baseurl后就能直接打开。\n搭建workflow 静态博客的工作流理想状态是本地修改内容后推送到远端，推送命令会触发远端更新网站。 拆解这个过程： 需要一个版本控制系统来管理每次修改的内容 远端需要有个存放源码的仓库 需要将网站源码推送到远端 远端需要一个静态网站托管服务/云主机 远端源码仓库有变动，就要重新用hugo命令生成一次public文件夹，并把变动后的public文件夹推送给托管网站/云主机 托管服务通过public文件夹展示网页 对应的步骤是： 使用git管理代码变化 将本地git仓库与GitHub仓库连接：用 SSH 方式配置多个账号连接 GitHub 新建两个GitHub仓库（GitHub有提供静态网站托管服务——GitHub Pages） 存放源码的仓库中用GitHub Actions建立CI/CD：Hugo workflow（检测到git push操作后将public文件夹推送给GitHub Pages绑定的仓库） 使用GitHub Pages部署项目 workflow 完成上面的步骤后，就能够在公网上看到网站了。\n进阶：修改主题 直接上手修改会很捉急，因为Hugo并不是直接用html、css、js代码粘合的，还需要了解一些必要的Go模板语言知识 直接看官方文档又多又杂，即使看完getting started也容易依然一头雾水 所以建议可以从自己下载好的主题代码出发，了解： 文件夹之间的对应关系 每个代码文件在页面中的作用 每个伪API的作用 一些小tips： .代表传入每个区域的上下文（context） layouts文件夹中最重要的是index.html，它是整个网站的home页面布局。 baseof.html是layouts/_default中每个文件布局的模板 Hugo有leaf bundle和branch bundle的概念： 图片来源：https://www.manning.com/books/hugo-in-action 每个branch bundle都是section，section页面默认对应list.html，根目录的section页面（比如上图的about）对应_default文件夹中的同名html文件（about.html） 每个leaf bundle都是single页面，所有single页面对应single.html Hugo没有subsection的概念，当section和subsection需要有不同布局的时候，如果不能修改生成器代码，就只能曲折地实现——把根目录下的section页面当作subsection 本博客中posts和notes中的单页面都对应single.html，但它们分属不同的section，所以可以拿sectionName来做区分 除了使用默认的tags和categories来分类外，可以自定义分类，本博客就自定义了notes分类。 layouts中相似的布局可以解耦出来，放到partials文件夹下。比如home页面和about页面都需要left banner，那么left banner就可以拆分出来作为一个组件。使用partials和定义blocks的区别： 图片来源：https://www.manning.com/books/hugo-in-action Hugo支持在markdown文件中插入html代码，可以直接插入标签，也可以用Go模板语言调用layouts中定义的shortcodes。 一些可能用到的参考： Page methods：每个single页面的 . 都是page object Go template: functions, operators, and statements collections.Where：常用来排除集合中某些项的函数 Collections functions：每个collection可以使用的函数 Compare functions：非常好用的比较函数 Glossary of terms：不懂得术语可以随时在此查询 添加内容 此时可以愉快地为博客添加内容了。因为每次添加frontmatter非常繁杂，所以建议基于archetypes文件夹中的模板来创建新markdown文档：\narchetypes文件夹中的每个文件对应一种内容类型，可以自定义： archetypes/default.md：用于没有指定内容类型时的默认模板。 archetypes/post.md：专门用于创建博客文章的模板。 archetypes/note.md：专门用于创建笔记页面的模板。 然后在根目录下，可以使用命令创建md文档： 1hugo new post/my-first-post.md 最后形成的使用动线 Blog Workflow\n参考 Hugo Docs: 内容多而全，适合查询 Hugo In Action：系统且挑重点，适合快速过一遍 Hugo tutorial by CloudCannon: Got a roughly picture of the file hierarchy of Hugo. Build Websites with Hugo: A complete guide. 不是从零开始的 Hugo 建站笔记 Create and host a blog with Hugo and GitHub Pages in less than 30 minutes Hugo | 在文章中插入轮播图片 ","date":"2023-01-09T13:50:03+08:00","image":"https://morimit.github.io/2023/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%80%BB/Journey_hu10297012887441808352.png","permalink":"https://morimit.github.io/2023/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%80%BB/","title":"如何使用Hugo搭建一个博客(总)"},{"content":"名词释义 webpage：能够显示在web浏览器上的文档 website：许多网页组合成网站 web server：在web上托管网站的服务器 search engine：能够帮助使用者查找网页的服务 连接上述诸位的就是web：内联网、外联网和互联网的范围见下图 图片来源: https://developer.mozilla.org HTTP：规范两台计算机间传输超文本的文本化无状态协议 图片来源: https://developer.mozilla.org IP address：任何连上互联网的电脑都能通过公共IP地址来访问 domain name：为互联网上任何可用的web服务器提供人类能理解的地址 Web 发展史 web history 博客属于web 2.0的产物，承载着使用者的表达和记录。\n","date":"2023-01-02T12:16:02+08:00","image":"https://morimit.github.io/2023/about-websites/blog-webdesignmuseum_hu3156939798219430765.png","permalink":"https://morimit.github.io/2023/about-websites/","title":"About Websites"}]