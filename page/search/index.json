[{"content":"REF 按照Waline官方文档可以快速上手配置 有不清楚的地方以及后面的邮件模板可以参照 失迹の博客 设置数据库（LeanCloud） 按照Waline文档的步骤走，注册好LeanCloud国际版\n博客选择开发者版本就够用了： LeanCloud price 记住三个应用凭证： AppID、AppKey、MasterKey 部署服务端（Vercel） 服务端可以通过 docker 进行部署或直接部署在自托管环境上，也可以部署到其他常见云平台，这里我选择用Vercel部署。\n按照Waline文档的步骤走，如果没有在仓库安装过Vercel，则会跳出安装页面： install Vercel create project deployment finish 上图分别展示了安装Vercel、创建项目、Vercel基于Waline模板自动化部署的过程。\n接下里是在这个项目里添加三个环境变量，分别对应上面的三个LeanCloud凭证： 环境变量 每次配置新的环境变量后都要重新部署： redeploy 部署成功后可以通过服务端地址访问服务端了： visit server 绑定域名（可选） 可以把vercel绑定自己的域名，这里我直接用vercel自动分配的域名了~\n配置客户端（Hugo博客） 此博客基于的Stack主题是集成了Waline评论模板的，只不过样式用的是v2，而目前官网已经更新到v3了，所以可以参考Waline文档把引入样式表和js脚本都换成v3的：\n在config.yaml文件中开启评论区并配置相关参数：\n1comments: 2 enabled: true 3 provider: waline 在layouts\\partials\\comments\\provider\\waline.html文件中修改代码：\n1 2\u0026lt;link 3rel=\u0026#34;stylesheet\u0026#34; 4href=\u0026#34;https://unpkg.com/@waline/client@v3/dist/waline.css\u0026#34; 5/\u0026gt; 6 7\u0026lt;div id=\u0026#34;waline\u0026#34; class=\u0026#34;waline-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 8 9\u0026lt;style\u0026gt; 10 .waline-container { 11 background-color: var(--card-background); 12 border-radius: var(--card-border-radius); 13 box-shadow: var(--shadow-l1); 14 padding: var(--card-padding); 15 --waline-font-size: var(--article-font-size); 16 } 17 .waline-container .wl-count { 18 color: var(--card-text-color-main); 19 } 20\u0026lt;/style\u0026gt; 21 22{{- with .Site.Params.comments.waline -}} 23{{- $config := dict \u0026#34;el\u0026#34; \u0026#34;#waline\u0026#34; \u0026#34;dark\u0026#34; `html[data-scheme=\u0026#34;dark\u0026#34;]` -}} 24{{- $replaceKeys := dict \u0026#34;serverurl\u0026#34; \u0026#34;serverURL\u0026#34; \u0026#34;requiredmeta\u0026#34; \u0026#34;requiredMeta\u0026#34; \u0026#34;wordlimit\u0026#34; \u0026#34;wordLimit\u0026#34; \u0026#34;pagesize\u0026#34; \u0026#34;pageSize\u0026#34; \u0026#34;avatarcdn\u0026#34; \u0026#34;avatarCDN\u0026#34; \u0026#34;avatarforce\u0026#34; \u0026#34;avatarForce\u0026#34; -}} 25 26 {{- range $key, $val := . -}} 27 {{- if $val -}} 28 {{- $replaceKey := index $replaceKeys $key -}} 29 {{- $k := default $key $replaceKey -}} 30 31 {{- $config = merge $config (dict $k $val) -}} 32 {{- end -}} 33 {{- end -}} 34 35 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; 36 import { init } from \u0026#39;https://unpkg.com/@waline/client@v3/dist/waline.js\u0026#39;; 37 38 init({{ $config | jsonify | safeJS }}); 39 \u0026lt;/script\u0026gt; 40{{- end -}} 看评论区右下角的Powered by Waline后面的版本号可以知道是否配置成功\n完成上面的步骤后，就可以在评论区留言了： comment area 登录管理端（评论管理） 部署完成后，请访问 \u0026lt;serverURL\u0026gt;/ui/register 进行注册。首个注册的人会被设定成管理员。 管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。 用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。 其中serverURL即服务端的地址 serverURL 注册后就可以管理评论了: server side comment management 解决Vercel DNS污染问题（待尝试） 可以参考这个博客 配置评论邮件通知 首先了解一下两个协议，SMTP是可以从邮件客户端向邮件服务端发送、中继或转发邮件的协议，IMAP是可以从邮件服务器上获取邮件信息、下载邮件的协议。\n图片来源：https://www.cnblogs.com/jiyuwu/p/16313476.html 这里我们通过配置Vercel的SMTP环境变量，每当有评论的时候就让SMTP服务端来发送邮件。\nSMTP服务端可以自己用服务器搭建，也可以选择各大邮件服务商。这里我一开始用Outlook邮件一直没成功，后面还是用Gmail了。\nGmail启用IMAP Gmail在打开IMAP的同时也会打开SMTP enable IMAP 此外还要打开Google账号的两步验证，然后才能生成一个App password（后面要填入环境变量）。\n开启163邮箱的IMAP/SMTP服务 Gmail被封了，还是用上了163邮箱。\n首先找到设置，开启IMAP/SMTP服务 163mail settings 比较坑的地方是授权码只有180天有效期。\n有个小坑：SMTP_USER的值必须和SENDER_EMAIL的值一致，否则会一直收不到邮件通知，再查看vercel的日志，会发现错误代码553\nmail error 配置Vercel环境变量 需要配置以下环境变量：\nSMTP_SERVICE：Gmail/163（如果是waline支持的运营商，就不用填SMTP_HOST 和 SMTP_PORT） SMTP_USER：youremail@gmail.com SMTP_PASS：gmail填上面获取的App password，有16位，要删除空格/163mail填SMTP授权码 SITE_NAME：填博客的名字 SITE_URL：https://your-site-domain-name AUTHOR_EMAIL：填自己常用的邮箱(最好是上面评论管理的管理员邮箱)，用来接收评论通知 以下是选填的环境变量:\nSENDER_NAME: Miaomi\u0026rsquo;s Blog SENDER_EMAIL: 自定义发送邮件的发件地址（如果使用gmail可以自定义，如果用163则必须保证此值和SMTP_USER一致） MAIL_SUBJECT: Dear {{parent.nick | safe}}，your comment on {{site.name | safe}}\u0026rsquo;s Blog received a reply MAIL_TEMPLATE: 自定义评论回复邮件内容(可直接贴HTML代码) MAIL_SUBJECT_ADMIN: 亲爱的站长，您的博客{{site.name | safe}}收到一条新评论，请及时回复哦~ MAIL_TEMPLATE_ADMIN: 自定义新评论通知邮件内容(可直接贴HTML代码) 记得每次配置好环境变量都要点redeploy才会生效\n一切准备就绪后，评论区有回复都能收到邮件通知了~\n默认的邮件模板如下： received mail 有时间一定要改一下模板，看着和我的主题色不太搭~\n","date":"2024-11-09T17:51:34+08:00","image":"https://morimit.github.io/2024/%E7%BB%99hugo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0waline%E8%AF%84%E8%AE%BA%E5%8C%BA%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/waline_hu7ccfcd83de153e1606f392220db04414_121037_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2024/%E7%BB%99hugo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0waline%E8%AF%84%E8%AE%BA%E5%8C%BA%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/","title":"给Hugo博客添加Waline评论区并设置邮件通知"},{"content":"什么是Google Analytics Google Analytics 4 (GA4) 是 Google 的一种网络分析工具，可让你免费跟踪和衡量网站上的用户流量和行为。\n给网站添加GA的跟踪代码 注册什么的直接跟着官方文档走，关键在于GA ID的设置上：\nset up data collection 这里是给博客添加GA代码，而Hugo博客生成器对GA本身有代码支持，所以选第二个\nadd the Google tag directly 继续跟着步骤走，找到这段代码\ntag instruction 将这段含有GA ID的代码保存到博客layouts根目录下的 _internal/google_analytics.html文件夹中\n然后在博客layouts/partials/head/head.html文件中使用该模板：\n1{{/* 防止hugo server的流量也计入流量监测 */}} 2{{- if not .Site.IsServer -}} 3 {{- template \u0026#34;_internal/google_analytics_async.html\u0026#34; . -}} 4{{- end -}} 5{{- partial \u0026#34;head/custom.html\u0026#34; . -}} 注意hugo v0.120.0之后不再使用.Site.IsServer： hugo version 在博客config文件中也添加：\n1# GA Tracking ID 2services: 3 googleAnalytics: 4 id: G-yourID 最后虽然文档说是30分钟，但我却是过几个小时后才在Google Analytics上看到访客数据。\nReferences 比较老的教程，但来龙去脉写得比较完整 与上面相反 主要步骤还是看最新的GA官方文档 ","date":"2024-11-07T13:06:27+08:00","image":"https://morimit.github.io/2024/%E7%BB%99hugo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0google-analytics/GA_hu7c586ecc9f921637190ef8e878e61ce6_110266_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2024/%E7%BB%99hugo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0google-analytics/","title":"给Hugo博客添加Google Analytics"},{"content":"为什么要做计划 在开始做计划前，必须问自己一个问题——为什么要做？\n这个问题的答案越具体越好。\n在没有问出这个问题，心中也没有答案的时候，就很容易做出这样的计划—— version 0 看着满满当当能做很多事情，可真当执行的时候，一开始就会发现超时的问题。\n如果超时了，却硬要按照计划走，没学会的东西硬标学会了，假账越累越多，学习债也越积越厚；如果不按计划走，改动的内容牵一发而动全身，就容易不知道计划该如何写了。\n注意，计划的把控在于三个方面：\n内心的动力（即为什么要做此计划） 方向感（来源于对计划的复盘和调整） 能够定期调整的计划 Version 0计划的方式看似参照了学校课程表，但别忘了，课程表不会管学生有没有真的掌握某个知识点，而是只管灌输知识的时间把控。\n完全跟着学校的课表走，牵一步走一步，容易让自身缺乏动力、实际计划调整和方向感。\n所以即使别人给定的计划再清晰，我们也还要再问自己一次：为什么要做计划？\n即使我们已经制定好了计划，执行到中段有点迷茫的时候，也可以随时回到这个问题——\n是为了学习某个技能/学科？ 是为了推进某个项目？ 是为了建立某个routine？ \u0026hellip; 做计划的那些年 第一阶段 第一阶段我做的计划虽然没有用timeline限制得那么紧了，但目标感不清晰，没有具体回答“为什么做计划”的问题。\n做出的计划大概是这样的：\nversion 1.0 乍一看时间都可以调整，没什么问题，但是内容不够细节（目标不够明确集中），导致容易产生每天都是同一天的疲倦感。\n第一阶段还使用过habitica打卡，这个软件采用游戏的形式，如果错过打卡会掉血条，坚持打卡能够升级。 habitica 游戏机制是好的，日常打卡任务和具有deadline的任务区分也很人性化，但是打卡任务依然给我一种西西弗斯式的疲倦感。\n第二阶段 第二阶段首先明确了记录的目的：记录真正在意的事情\n其次明确了笔记的类型：\n封存层：我的记录，如日记、书影音笔记、收集的素材、方法论等 构思层：我的想法，如各种头脑风暴和brain dump 行动层：我的行动，如每日、周、月、年计划的执行log或打卡表 最后明确两个视角\n时间视角：每日-每周-每月-每年的plan \u0026amp; log 项目视角：总deadline-每个拆分项的deadline 这个阶段我用到了A4纸和OneNote，制作周、月、年计划：\nweekly plan 左上角是目标打卡和周复盘\nmonthly plan 左下角是月度目标和月复盘\nyearly plan 第三阶段 这个阶段，我保留了时间视角的月计划和年计划，使用obsidian的daily notes插件记录日计划: daily notes 最后还新增了项目视角的计划表：\nproject management 本质上只要保持住daily notes的记录，坚持每天写一点，那么月计划和年计划就有素材可以复盘，项目表也会有记录可以追踪。\n如何做计划 总结一下做计划的过程：\n知道为什么要做计划、想要达成的目标，越具体越好 大方向用项目管理视角来管控 并将目标拆解到每日、周、月，进行记录和定期复盘 ","date":"2024-11-05T11:29:51+08:00","image":"https://morimit.github.io/2024/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AE%A1%E5%88%92/typing_huae7e0b89b334da2d90b0544c5abc8aba_1545660_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2024/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AE%A1%E5%88%92/","title":"如何做计划"},{"content":"关于GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\n更多概念可参考相关文档：about github pages\n一些重点：\n用户站点：\u0026lt;username\u0026gt;.github.io 项目站点：http(s)://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt; 只能为 GitHub 上的每个帐户创建一个用户或组织站点。 项目站点（无论是组织还是个人帐户拥有）没有限制。 如果要创建用户或组织站点，则存储库必须命名为 \u0026lt;user\u0026gt;.github.io 或 \u0026lt;organization\u0026gt;.github.io，且名称必须使用小写字母 部署博客项目 博客项目部署在用户站点的根目录下，仓库命名根据上面的规则使用\u0026lt;user\u0026gt;.github.io格式： GitHub Pages设置 部署小项目 项目站点的仓库名会作为访问路径的一部分，同样需要在Pages中设置： 添加项目分支 添加项目的网址路径 完成后就可以通过此网址访问项目了： 访问项目 ","date":"2024-10-28T13:17:28+08:00","image":"https://morimit.github.io/2024/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAgithub-pages%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/pages0_hua59ada494a1898c539adc4763e474720_37595_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2024/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAgithub-pages%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","title":"使用一个GitHub pages部署多个项目"},{"content":"reference explainthis:DevOps 万字长文详解DevOps及DevOps工具链 阮一峰的博客 诞生背景 CI/CD是Continuous Integration（持续集成）和Continuous Delivery/Deployment（持续交付）的缩写。它产生于倡导敏捷开发的大背景下（普遍使用光盘的年代），软件开发不再是一次完成、测试后才上线交付，而是及早交付、开发者收到反馈后根据变动的需求持续改进的过程。\nCI/CD是DevOps的重要组成部分：\nDevOps工具链的核心组成部分包括：\n代码编辑和版本控制工具：如 Visual Studio Code，Sublime Text 等，它们允许开发人员编写代码并跟踪更改。 自动化构建工具：如 Jenkins，Travis CI 等，它们帮助开发人员自动化构建，测试和部署代码。 持续集成和持续部署工具：如 GitHub Actions，Jenkins X，GitLab CI/CD 等，它们帮助开发人员自动触发构建，测试和部署流程。 容器编排工具：如 Kubernetes，Docker Swarm 等，它们允许开发人员部署和管理容器化应用程序。 持续监控工具：如 Prometheus，Grafana，InfluxDB 等，它们帮助开发人员监控应用程序的运行状态和性能。 服务配置管理工具：如 Ansible，Chef，Puppet 等，它们帮助开发人员自动化配置和管理应用程序和服务。 DevOps工具链中的每个工具都旨在帮助开发人员更快地交付高质量的软件。通过这些工具，开发人员可以自动化许多重复性和耗时的任务，从而节省时间并提高生产效率。同时，DevOps工具链也可以帮助开发人员更好地理解应用程序的运行情况，并及时发现和解决问题。\n定义 CI CI指多个开发者能够共同在同个代码库中开发不同的新功能，然后在通过自动化测试后持续地整合到主干上面。\n一般来说，CI 流程会在代码推到远端分支后开始 代码格式化检查：统一代码的格式规范，确保具有符合团队设定的格式风格，例如 JavaScript 的 Prettier。 静态检查：确保有符合团队所设立的相关规则，或者有符合程式语言的规则，例如TypeScript 的 TSLint 会帮忙检查代码是否符合 TypeScript 的规则。 自动化测试：包含单元测试、功能测试、E2E 测试。 单元测试：针对函数或模块的测试 功能/集成测试：针对整体产品的某个功能的测试 端对端测试：从用户界面直达数据库的全链路测试 完成测试后构建：构建（build）指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 Jenkins Travis Codeship Strider 在业界，许多软件开发团队还会在 CI 当中加入其他更精细的检测，例如针对安全 (security) 做检测，避免写出有潜在漏洞的代码；或者对性能 (performance) 做检测，来确保代码的性能达到一定的门槛。\nCD CD指持续交付给评审团队、持续自动化部署。\n自动化测试：构建完成，就要进行第二轮全面测试。当然也可以只在构建完成后进行全面测试。 所有测试以自动化为主，少数无法自动化的测试用例就要人工跑 新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 部署：通过了前面的测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。 CD最理想的状况是当开发者把代码合并后，就会开始整合、测试，最终部署，整个流程不需用有人工介入，一切自动化完成，新的功能就会到最端使用者手上。\n","date":"2024-10-28T09:20:09+08:00","image":"https://mlops-guide.github.io/MLOps/CICDML/ci-cd.png","permalink":"https://morimit.github.io/2024/%E4%BB%80%E4%B9%88%E6%98%AFci/cd/","title":"什么是CI/CD"},{"content":"","date":"2024-10-04T17:05:36+08:00","permalink":"https://morimit.github.io/javascript/chapter1/1.1/","title":"1.1 基础语法"},{"content":" ","date":"2024-10-04T17:05:36+08:00","permalink":"https://morimit.github.io/javascript/chapter1/1.2/","title":"1.2 代码质量"},{"content":"","date":"2024-09-29T20:46:15+08:00","permalink":"https://morimit.github.io/javascript/chapter2/2.1/","title":"2.1 第一节"},{"content":"需求 将微信接龙打卡更新到考勤表中，已到的人✔，未到的人❌\n思路拆分 对比两列，一列是人员姓名（固定列），一列是此人当日打卡情况。每次微信打卡后，复制接龙到表格的对比列中，如果固定列的名字有出现在对比列中，则更新当日打卡记录。\n1cells = sheet[\u0026#39;A3:A11\u0026#39;] #固定列 2cells2 = sheet[\u0026#39;N3:N12\u0026#39;] #对比列 3cells3 = sheet[\u0026#39;C3:C11\u0026#39;] #保存到新列，每日更新 姓名\\日期 10月5日 10月6日 张三 ✔ ✔ 李四 ❌ ✔ 王五 ✔ ✔ 使用的python包：openpyxsl模块 参考教程：https://blog.csdn.net/weixin_44288604/article/details/120731317\n1import os 2import openpyxl 3import chardet 4import codecs 5 6 7path = r\u0026#34;C:\\\\Users\\\\DELL\\\\Desktop\\\\work\u0026#34; 8os.chdir(path) # 修改工作路径 9 10workbook = openpyxl.load_workbook(\u0026#39;志愿者考勤表.xlsx\u0026#39;)\t# 返回一个workbook数据类型的值 11# print(workbook.sheetnames)\t# 打印Excel表中的所有表 12 13# 选择工作表 14sheet = workbook[\u0026#39;Sheet1\u0026#39;] # 获取指定sheet表 15 16cells = sheet[\u0026#39;A3:A11\u0026#39;] #固定列 17cells2 = sheet[\u0026#39;N3:N12\u0026#39;] #对比列 18cells3 = sheet[\u0026#39;C3:C11\u0026#39;] #保存到新列，每日更新 19 20for i in cells: 21 for j in i: 22 # 打印A3到A11的数据 23 # print(j.value) 24 for k in cells2: 25 for l in k: 26 # 打印N3到N12的数据 27 # print(l.value) 28 if(l.value != None): 29 if(j.value.find(l.value) == -1): 30 print(l.row) 31 else: 32 sheet[\u0026#34;C{}\u0026#34;.format(j.row)].value = \u0026#39;✔\u0026#39; 33for k in cells3: 34 for l in k: 35 if( sheet[\u0026#34;C{}\u0026#34;.format(l.row)].value != \u0026#39;✔\u0026#39;): 36 print(l.row) 37 sheet[\u0026#34;C{}\u0026#34;.format(l.row)].value = \u0026#39;×\u0026#39; 38 39 40workbook.save(\u0026#39;志愿者考勤表.xlsx\u0026#39;) #记得保存，否则更改不生效 需求变更 要求整张表的行列对调 日期\\姓名 张三 李四 王五 10月5日 ✔ ❌ ✔ 10月6日 ✔ ✔ ✔ 1import os 2import openpyxl 3import chardet 4import codecs 5 6 7path = r\u0026#34;C:\\\\Users\\\\DELL\\\\Desktop\\\\work\\\\考勤表\u0026#34; 8os.chdir(path) # 修改工作路径 9 10workbook = openpyxl.load_workbook(\u0026#39;志愿者考勤表.xlsx\u0026#39;)\t# 返回一个workbook数据类型的值 11# print(workbook.sheetnames)\t# 打印Excel表中的所有表 12 13# 选择工作表 14sheet = workbook[\u0026#39;Sheet1\u0026#39;] # 获取指定sheet表 15alignment = openpyxl.styles.Alignment(horizontal=\u0026#34;center\u0026#34;, vertical=\u0026#34;center\u0026#34;, text_rotation=0, wrap_text=True) # 设置对齐格式 16def columnletter(col): 17 letter = [0, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;] 18 return letter[col] 19 20for i in sheet.iter_rows(min_row=2, max_row=2, min_col=2, max_col=10): 21 for j in i: 22 # 打印固定行（姓名行） 23 # print(j.value) 24 for k in sheet.iter_rows(min_row=16, max_row=16, min_col=1, max_col=10): 25 for l in k: 26 # 打印对比行（excel手动转置） 27 # print(l.value) 28 if(l.value != None): 29 if(j.value.find(l.value) == -1): 30 #print(l.column) #注意打印出来的是数字，而不是字母 31 else: 32 # ----------------------- 33 #新信息注入新行，打勾 34 # ----------------------------- 35 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(j.column))].value = \u0026#39;✔\u0026#39; 36 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(j.column))].alignment = alignment 37# ----------------------------- 38#新信息注入新行，打叉 39# ----------------------------- 40for k in sheet.iter_rows(min_row=5, max_row=5, min_col=2, max_col=10): 41 for l in k: 42 if( sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].value != \u0026#39;✔\u0026#39;): 43 print(l.column) 44 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].value = \u0026#39;×\u0026#39; 45 sheet[\u0026#34;{}5\u0026#34;.format(columnletter(l.column))].alignment = alignment 46 47workbook.save(\u0026#39;志愿者考勤表.xlsx\u0026#39;) ","date":"2023-10-05T09:58:39+08:00","image":"https://morimit.github.io/2023/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel/openpyxl_hu866701c10759c1e383c1833c73609b55_33637_120x120_fill_box_smart1_3.PNG","permalink":"https://morimit.github.io/2023/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel/","title":"使用Python操作Excel"},{"content":"本章图片来源：hugo in action\n博客类型 从博客使用者的角度，按照是否有后台能够在线编辑博文，博客可分为：\n静态博客 动态博客 从博客开发的角度看，动态博客多了应用服务器和数据库的部分。 典型动态博客架构 | 来源：https://www.manning.com/books/hugo-in-action 一些流行的Web技术栈包括LAMP(Linux、Apache、MySQL、PHP)、Microsoft.NET(IIS、ASP.NET、MS SQL Server)、MEAN(MongoDB、Express、Angular、Node.js)和MERN(MongoDB、Express、Reaction、Node.js)。\n像Apache或IIS这样的Web服务器主要在传统的Web技术栈中托管静态资产，如图像、JavaScript和CSS,这些静态文件不会在多个用户之间更改。 第二组资产是动态内容，可以有所不同，它基于提供的请求参数，包括URL，请求标头，cookie或相关的HTTP POST数据，安装了PHP、ASP.NET或Express等软件的应用程序服务器会获取这些参数并创建响应\n动态博客 可以登录并进入网页后台在线编写文章、管理评论，发布和修改文章比静态博客方便，可以实时更新 搭建时需要租用/购买服务器，要考虑服务器的安全问题 halo 开源建站工具，不用写代码，直接生成网页，但要有一台可访问公网的服务器（云主机或实体服务器），并需要进行以下服务器配置：\n服务器的连接与管理：SSH工具（如SecureCRT）、SFTP工具（向服务器上传文件） 服务器应用安装与环境部署 准备网站源码或安装包（jar包）进行部署。 防火墙开放8090端口，这是网站打开访问的端口 (xxx.xxx.xxx.xxx:8090）。 可以下载一些主题包，在控制台页面安装。 在服务器上安装nginx。一般来说我们不会用jar包启动的8090端口的服务去直面用户，而是会在中间加一层代理服务器做转发服务（负载均衡、扛并发）。常用的代理服务器就是nginx（默认在80端口启动web服务）。 配置nginx，让它代理到jar包启动的地址（xxx.xxx.xxx.xxx:8090），即可不用写8090端口访问。 Wordpress 可用docker搭建；基于PHP语言；搭建步骤大致如下：\n购买主机和域名 安装docker 搭建博客。下载docker-compose.yml文件，再用一行命令启动博客（yml文件里包含了从docker官方仓库拉取服务镜像，包括mysql和需要的web服务）。 登录（localhost:8000），选择语言、登录账户设置，即可以看到博客后台。 最后可更换主题和插件 静态博客 使用博客生成器生成网站（一个包含一堆HTML文件的文件夹），每次发布/修改内容都需要重新生成此文件夹 网站放在托管平台，利用GitHub Pages、Netlify、vercel等可以做免费托管，无需购买服务器 利用GitHub Actions实现简单的CI/CD 缺点是扩展时受限于生成器提供的API 了解博客生成器之前，最好先了解Jamstack。J、A、M分别代表JavaScript、APIs、Markup，也即此技术栈的核心：\nJamstack | 来源：https://www.manning.com/books/hugo-in-action 首次发出获取HTML页面的请求运行时Jamstack与传统Web技术栈的对比： 与动态站点的web技术栈对比 | 来源：https://www.manning.com/books/hugo-in-action 使用Jamstack，编译步骤已经执行了数据库处理和基于应用程序逻辑的拼接。 这种HTML生成并不是针对每个请求都发生的。 因此，该请求不需要通过互联网访问原始服务器。 而是在地理位置上靠近客户端的CDN提供内容。\n可以看到Jamstack将大部分逻辑从应用程序中移出到web服务器，与应用程序服务器相比，web服务器的安全问题和维护需求更少，如果使用托管服务，则能最大程度减少维护工作。\nHugo 基于Go语言；生成站点的速度非常快。\nHexo 基于Node.js，很多主题稍作修改后Hugo也可以用。\n","date":"2023-03-16T09:33:30+08:00","image":"https://morimit.github.io/2023/different-blog-types/hugo_hufdb59a3ab1755e5557c14674f8a0c728_59951_120x120_fill_box_smart1_3.PNG","permalink":"https://morimit.github.io/2023/different-blog-types/","title":"Different Blog Types"},{"content":"添加文章 关于notes和posts 本博客中二者的划分可查看：notes和posts区域\n添加posts文章 不需要指定模板，Hugo会使用 archetypes/default.md模板来建立文档：\n1hugo new post/my-first-post.md 添加notes文章 指定模板，使用命令hugo new [文件路径]/[文件名].md -k [archetype name]\n比如添加JavaScript这个笔记，需要按照如下格式：\n在./content目录下新建javascript文件夹和_index.md 1hugo new javascript/_index.md -k note-section.md 在./content/javascript目录下添加chapter： 1hugo new javascript/chapter1/_index.md -k note-section.md 在./content/javascript/chapter1目录下添加每一节： 1hugo new javascript/chapter1/1.1/index.md -k note.md 最后可以用hugo server 命令查看修改效果，如果再加上--buildDrafts可以查看草稿文件 ： sample note 将本地变化推送到远程仓库 1git pull 2git add . #添加修改后的所有文件到stage area 3git commit -m \u0026#34;添加评论\u0026#34; #把stage area的文件提交到分支 4git push origin main #推送到源码仓库 5# 最后可在`https://xxxxx.github.io` 处查看发布好的网站。 改动博客样式 切换到测试分支开发 1git branch #查看所有分支 2git checkout -b test #新建并切换到test分支 完成后合并到main分支 1git switch main #切换到main分支 2git merge --no-ff -m \u0026#34;merge with no-ff\u0026#34; test #在非fast forward模式下合并分支 3git log --graph --pretty=online --abbrev-commit #可以查看合并结果 4git push origin main 5#手动删除远程仓库内的test分支 6git branch -d test #删除本地test分支 7git fetch --prune #删除远程仓库中删除的分支的引用 ","date":"2023-01-11T20:59:31+08:00","image":"https://morimit.github.io/2023/blog-workflow/Journey2_hu3a7c6765f2e48ec02e633c4343bd6058_2950906_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2023/blog-workflow/","title":"Blog Workflow"},{"content":"场景 需要用一台（Windows）电脑同时连接多个GitHub账号。\n建立SSH连接 创建两个SSH key 在终端输入以下命令：\n1ssh-keygen -t rsa -f ~/.ssh/id_rsa_m -C \u0026#34;firstmail@gmail.com\u0026#34; #绑定一个GitHub账号所用的邮箱 2ssh-keygen -t rsa -f ~/.ssh/id_rsa -C \u0026#34;secondmail@gmail.com\u0026#34; #绑定另一个GitHub账号的邮箱 添加SSH公钥到对应GitHub账号中 两个SSH key分别配置在对应GitHub账号中： sshkey 本地添加新SSH密钥到SSH agent中 在终端中输入命令：\n1ssh-add -D #清空本地的SSH缓存 2ssh-add ~/.ssh/id_rsa 3ssh-add ~/.ssh/id_rsa_m 4ssh-add -l 若提示 Could not open a connection to your authentication agent. 则先执行命令 ssh-agent bash 即可。\n修改本地配置文件 要在本地配置文件中设置不同账号和SSH key的对应关系，就需要在 ~/.ssh/config 文件（没有就新建一个）中设置不同仓库指向不同的密钥文件：\n1#第一个账号 2Host github.com # 这里域名随意写，标识账号1 3HostName github.com #这里域名就是我们要访问的远程服务器域名github.com 4User git #可以随意填写 5IdentityFile ~/.ssh/id_rsa #私钥位置 6 7# 第二个账号 8Host second.github.com #标识账号2 9HostName github.com 10User git 11PreferredAuthentications publickey 12IdentityFile ~/.ssh/id_rsa_m 测试SSH连接 在终端中执行命令\n1ssh -T git@github.com 2ssh -T git@second.github.com 提示 Hi Morimit! You've successfully authenticated, but GitHub does not provide shell access 则为成功。\n配置git 配置项目文件夹信息 在项目文件夹中打开终端并执行以下命令：\n1# 取消全局 用户名/邮箱 配置 2$ git config --global --unset user.name 3$ git config --global --unset user.email 4# 进入项目文件夹，单独设置每个repo 用户名/邮箱 5$ git config user.email \u0026#34;xxxx@xx.com\u0026#34; 6$ git config user.name \u0026#34;xxxx\u0026#34; 7$ git config --list 配置远程仓库信息 注意设置远程仓库的时候，需要与 config 文件中的Host名称对应。\n1$ git remote rm origin 2# 远程仓库地址，注意Host名称 3$ git remote add origin git@second.github.com:githubUserName/repName.git 4$ git remote -v # 查看远程 将本地仓库上传到远程仓库 push测试：\n1git add . 2git commit -m \u0026#34;自行添加注释\u0026#34; 3git push origin main #推送到远端main分支 流程总结 确保SSH连接成功 在项目文件夹目录下打开git bash终端。 将文件夹设为git仓库： git init 在本地添加远程仓库的SSH地址 1git remote add origin git@second.github.com:Morimit/Morimit_source.git (注意这里的账号名 git@second.github.com 是和 ~/.ssh/config 文件中配置一致的) 配置git账号: git config user.name \u0026quot;Morimit\u0026quot; 和 git config user.email \u0026quot;firstmail@gmail.com\u0026quot; 。 添加到暂存区和提交到当前分支： git add . 、 git commit -m \u0026quot;comments\u0026quot; 推送到远程仓库： git push origin main 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream \u0026lt;branch-name\u0026gt; origin/\u0026lt;branch-name\u0026gt;。 参考 github-手把手教程-本地如何连接多个github仓库_Vivi_static的博客-CSDN博客 Git之同一台电脑连接多个远程仓库 - zhengyan_web - 博客园 (cnblogs.com) 本地Git仓库关联多个远程仓库的两种方法 - 知乎 (zhihu.com) ","date":"2023-01-10T16:22:12+08:00","image":"https://morimit.github.io/2023/connect-git-to-github/SSH_hu76ac48c9296eadc7f5b04813fe8b3453_968435_120x120_fill_box_smart1_3.PNG","permalink":"https://morimit.github.io/2023/connect-git-to-github/","title":"Connect Git to Github"},{"content":"Reference GitHub Actions 入门教程 Build Hugo With GitHub Action Create and host a blog with Hugo and GitHub Pages in less than 30 minutes Creating a personal access token 基于 Github Action 自动构建 Hugo 博客 - (lixueduan.com)：讲清楚了GitHub Action中的.yml配置文件代码具体是怎样连接GitHub上的两个仓库的 折腾Hugo | GitHub Pages | Github Actions自动构建发布免费个人网站 - 知乎 (zhihu.com) ：看完就能知道怎么给GitHub上的两个仓库配置公钥私钥 使用 Hugo + GitHub Actions 升级博客 // 风行\u0026rsquo;s Blog (lijingcheng.github.io) ssh-keygen 生成密钥 Prerequisite 建立好本地仓库和GitHub的连接：Connect Git to GitHub\nSteps Github Actions是GitHub提供的，使用脚本的大致作用如下：\nThe GitHub Action is going to grab the content from the XXX_source repository, build it using Hugo and push the output into the XXX repository.\n创建一个新的SSH密钥对： 1ssh-keygen -t rsa -b 4096 -C \u0026#34;yourmail@mail.com\u0026#34; -f ~/.ssh/gh-pages -N \u0026#34;\u0026#34; 给绑定GitHub Pages的公开仓库添加公钥： ssh-pub 给源码仓库添加私钥： 注意：此 private key 的名称之后要填入 Action 脚本的特定位置。 ssh-private 给源码仓库添加脚本 在源码仓库中找到Actions栏，新建workflow： new workflows 可以直接找到workflow的模板： workflow templates template 可以在右侧查看actions市场和GitHub Actions的使用文档： actions \u0026amp; docs 修改脚本内容 一些专用术语：\nworkflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 脚本内容修改如下：\n1name: Deploy Hugo Site to Github Pages on Main Branch 2 3# 触发条件是git push 4on: 5 push: 6 branches: 7 - main 8 - test 9 10jobs: 11 build-deploy: 12 runs-on: ubuntu-latest 13 steps: 14 - uses: actions/checkout@v1 # v2 does not have submodules option now 15 # with: 16 # submodules: true 17 18 - name: Setup Hugo 19 uses: peaceiris/actions-hugo@v2 20 with: 21 # The Hugo version to download (if necessary) and use. Example: 0.58.2 22 hugo-version: \u0026#39;0.108.0\u0026#39; # default is \u0026#39;latest\u0026#39;, better use your local development version 23 extended: true 24 25 - name: Build 26 run: hugo --minify 27 28 - name: Deploy 29 uses: peaceiris/actions-gh-pages@v3 30 with: 31 deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名 32 external_repository: Morimit/Morimit.github.io # Pages绑定的远程仓库 33 publish_dir: \u0026#34;./public\u0026#34; 34 keep_files: false # remove existing files 35 publish_branch: main # deploying branch 36 commit_message: ${{ github.event.head_commit.message }} 注意：publish_branch要和该仓库绑定GitHub Pages的发布branch相一致 上面的步骤完成后，每次从本地git push源文件到GitHub都会触发GitHub Actions脚本把./public文件夹更新到GitHub pages。 搭建完成后的workflow workflow\n","date":"2023-01-10T13:50:03+08:00","image":"https://morimit.github.io/2023/building-blog-with-github-actions/actions_hu03a58e8a8f7ee10093a426c7be209910_110343_120x120_fill_box_smart1_3.PNG","permalink":"https://morimit.github.io/2023/building-blog-with-github-actions/","title":"Building Blog With GitHub Actions"},{"content":"博客规划 定位 明确自己的核心需求就两个：\n技术笔记本 一些其他posts 页面规划 主页 参考一些博客、小说、视频、新闻网站，展示页适合使用摊开的卡片形式，可以一目了然地看到所有posts的信息 posts在本博客中是使用tags来管理的、互相没有上下级关联的博文 笔记 存放所有notes——以文档的形式罗列，每个note都具有总体章节目录和本节内容目录 notes在本博客中是使用notes分类来管理、互相之间有层级关系的博文，且不会出现在主页展示 由于页面的布局很满了，所以目录的滚动条都要隐藏，鼠标放在目录上能滚动即可 还有有种方式是折叠目录，但我更喜欢摊开的感觉 项目 存放一些小项目。\n存档 存放所有notes和posts中的博文，考虑到博文的数量，按年份来分隔比较合理，并且不需要分页，因为分页有种切割了时间流的感觉。\n关于 关于网站的信息和一些碎碎念。\nRSS订阅 可以使用inoreader等RSS阅读器来订阅博文。\n搭建记录 一句话总结 首先Hugo能够生成可以发布的静态网站文件，其次使用Git进行版本控制，每次修改后可以把源码传到GitHub，最后GitHub对Hugo建站有完整的支持组件（GitHub Actions、GitHub Pages），所以才能顺利完成一系列自动部署。\n初始化git仓库 git是一个分布式版本控制系统，可以用来追踪博客的成长变动。\n把存放博客的文件夹变成一个git仓库：\n1git init 本地安装Hugo 安装环境：Windows 10 安装步骤参考官方文档，或者中文文档 在这里我安装预编译的二进制版本，此版本是已经编译好的应用程序，不依赖Go环境，优点是可以直接运行，缺点是不能直接修改源码。\n下载后需要添加环境变量，这样才能够在不同的文件夹中使用Hugo程序。在系统变量和用户变量的Path中都添加： hugo文件夹添加到系统变量 然后就可以进入想要存放博客的文件夹，使用命令创建新站：\n1 hugo new site 项目名 此时在根目录文件夹下可以发现Hugo已经创建了一些文件夹： 文件夹框架 选择并了解Hugo主题 本博客主题选用参考了Hugo-stack-theme 主题魔改版 stack主题的特点之一是使用原生JS和CSS代码，没有使用框架。 直接下载Stack主题到./themes文件夹中，并按照主题readme文档的提示进行一些配置。\n再回到根目录下使用命令来预览：\n1hugo server 这条命令会在运行内存中构建网站，并让网页跑在一个最小化的HTTP server中，这意味着可以一边修改网站一边看到修改效果。\nExample Site 关于web server更详细的解释：\nWhile the server is running, it watches your project directory for changes to assets, configuration, content, data, layouts, translations, and static files. When it detects a change, the server rebuilds your site and refreshes your browser using LiveReload.\nabout LiveReload: While the server is running, Hugo injects JavaScript into the generated HTML pages. The LiveReload script creates a connection from the browser to the server via web sockets. You do not need to install any software or browser plugins, nor is any configuration required.\n注意Hugo都是从根目录开始渲染的，所以如果根目录的layouts和contents有内容，就会忽略themes文件夹中的同名文件夹。\n以及如果出现不同后缀名的config文件，不同格式的优先级是toml\u0026gt;yaml\u0026gt;json。\n（优先级细节可查看官方文档的lookup order）\n创建网站 真正创建网站的是下面一行命令：\n1hugo 此命令会在网站根目录下创建public文件夹，这里存放的就是整个完整的网站，如果把public文件夹放在IIS之类的web服务器上，稍加修改config.yaml文件中的baseurl后就能直接打开。\n搭建workflow 静态博客的工作流理想状态是本地修改内容后推送到远端，推送命令会触发远端更新网站。 拆解这个过程： 需要一个版本控制系统来管理每次修改的内容 远端需要有个存放源码的仓库 需要将网站源码推送到远端 远端需要一个静态网站托管服务/云主机 远端源码仓库有变动，就要重新用hugo命令生成一次public文件夹，并把变动后的public文件夹推送给托管网站/云主机 托管服务通过public文件夹展示网页 对应的步骤是： 使用git管理代码变化 将本地git仓库与GitHub仓库连接：用 SSH 方式配置多个账号连接 GitHub 新建两个GitHub仓库（GitHub有提供静态网站托管服务——GitHub Pages） 存放源码的仓库中用GitHub Actions建立CI/CD：Hugo workflow（检测到git push操作后将public文件夹推送给GitHub Pages绑定的仓库） 使用GitHub Pages部署项目 workflow 完成上面的步骤后，就能够在公网上看到网站了。\n进阶：修改主题 直接上手修改会很捉急，因为Hugo并不是直接用html、css、js代码粘合的，还需要了解一些必要的Go模板语言知识 直接看官方文档又多又杂，即使看完getting started也容易依然一头雾水 所以建议可以从自己下载好的主题代码出发，了解： 文件夹之间的对应关系 每个代码文件在页面中的作用 每个伪API的作用 一些小tips： .代表传入每个区域的上下文（context） layouts文件夹中最重要的是index.html，它是整个网站的home页面布局。 baseof.html是layouts/_default中每个文件布局的模板 Hugo有leaf bundle和branch bundle的概念： 图片来源：https://www.manning.com/books/hugo-in-action 每个branch bundle都是section，section页面默认对应list.html，根目录的section页面（比如上图的about）对应_default文件夹中的同名html文件（about.html） 每个leaf bundle都是single页面，所有single页面对应single.html Hugo没有subsection的概念，当section和subsection需要有不同布局的时候，如果不能修改生成器代码，就只能曲折地实现——把根目录下的section页面当作subsection 本博客中posts和notes中的单页面都对应single.html，但它们分属不同的section，所以可以拿sectionName来做区分 除了使用默认的tags和categories来分类外，可以自定义分类，本博客就自定义了notes分类。 layouts中相似的布局可以解耦出来，放到partials文件夹下。比如home页面和about页面都需要left banner，那么left banner就可以拆分出来作为一个组件。使用partials和定义blocks的区别： 图片来源：https://www.manning.com/books/hugo-in-action Hugo支持在markdown文件中插入html代码，可以直接插入标签，也可以用Go模板语言调用layouts中定义的shortcodes。 一些可能用到的参考： Page methods：每个single页面的 . 都是page object Go template: functions, operators, and statements collections.Where：常用来排除集合中某些项的函数 Collections functions：每个collection可以使用的函数 Compare functions：非常好用的比较函数 Glossary of terms：不懂得术语可以随时在此查询 添加内容 此时可以愉快地为博客添加内容了。因为每次添加frontmatter非常繁杂，所以建议基于archetypes文件夹中的模板来创建新markdown文档：\narchetypes文件夹中的每个文件对应一种内容类型，可以自定义： archetypes/default.md：用于没有指定内容类型时的默认模板。 archetypes/post.md：专门用于创建博客文章的模板。 archetypes/note.md：专门用于创建笔记页面的模板。 然后在根目录下，可以使用命令创建md文档： 1hugo new post/my-first-post.md 最后形成的使用动线 Blog Workflow\n参考 Hugo Docs: 内容多而全，适合查询 Hugo In Action：系统且挑重点，适合快速过一遍 Hugo tutorial by CloudCannon: Got a roughly picture of the file hierarchy of Hugo. Build Websites with Hugo: A complete guide. 不是从零开始的 Hugo 建站笔记 Create and host a blog with Hugo and GitHub Pages in less than 30 minutes Hugo | 在文章中插入轮播图片 ","date":"2023-01-09T13:50:03+08:00","image":"https://morimit.github.io/2023/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%80%BB/Journey_hu1d161e49501ed6cf448ab5500d479d0f_4442675_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2023/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%80%BB/","title":"如何使用Hugo搭建一个博客(总)"},{"content":"名词释义 webpage：能够显示在web浏览器上的文档 website：许多网页组合成网站 web server：在web上托管网站的服务器 search engine：能够帮助使用者查找网页的服务 连接上述诸位的就是web：内联网、外联网和互联网的范围见下图 图片来源: https://developer.mozilla.org HTTP：规范两台计算机间传输超文本的文本化无状态协议 图片来源: https://developer.mozilla.org IP address：任何连上互联网的电脑都能通过公共IP地址来访问 domain name：为互联网上任何可用的web服务器提供人类能理解的地址 Web 发展史 web history 博客属于web 2.0的产物，承载着使用者的表达和记录。\n","date":"2023-01-02T12:16:02+08:00","image":"https://morimit.github.io/2023/about-websites/blog-webdesignmuseum_huaf5415bb0c4a6374a5c178fcad28078d_482607_120x120_fill_box_smart1_3.png","permalink":"https://morimit.github.io/2023/about-websites/","title":"About Websites"}]